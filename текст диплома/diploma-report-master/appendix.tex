\begin{center}
  \section{ }%Выражение для поляризуемости}
  \label{sec:polarizability}
\end{center}

% ~\ref{sec:wave_equation}
Приведем упрощенный вывод Фурье компонент  $\chi_h$  для рентгеновской
поляризуемости в среде  $\chi(\vec{r})$. Если в какой либо точке находится электрон,
то уравнение его движения под действием электромагнитной волны,
исходя из второго закона Ньютона, запишется в виде \cite{iveronova1972}.
\begin{equation}
  \ddot{x}+ k\dot{x} + \omega_0^2 x = \frac{e}{m}E_0e^{i\omega t}
 \end{equation}
Откуда смещение этого заряда
\begin{equation}
  x = \frac{e}{m} \frac{E_0e^{i\omega t}}{\omega_0^2 - \omega^2+i\omega t}
 \end{equation}
где $\omega_0 $ - собственная частота колебания электрона (частота электронного перехода), $\omega$ - частота рентгеновского излучения.

Поляризация единицы объема в заданной точке пространства $P$ определяется из условия
$P = \frac{\sum e x}{\Delta V}$. Суммирование проводится по всем зарядам в
некотором малом объеме  $\Delta V$.

Для рентгеновских лучей обычно $\omega_0^2 << \omega^2$, поэтому
\begin{equation}
  4\pi P = - \frac{4\pi e^2}{m\omega^2}\frac{\Delta N}{\Delta V} E_0 e^{i\omega t} = -\frac{e^2 \lambda^2}{m \pi c^2} \rho E_0 e^{i\omega t}
 \end{equation}
где $\Delta N$ - число зарядов в объеме $\Delta V$;
$\rho = \frac{\Delta N}{\Delta V}$ - электронная плотность в заданной точке пространства.


\begin{equation}
  \chi_h = -\frac{e^2 \lambda^2}{m \pi c^2}  \rho = -\frac{e^2 \lambda^2}{m \pi c^2} \frac{F_h}{V}
 \end{equation}
 где, $ F_h = \sum_{n} f_n \cdot e^{-2\pi i\vec{h}\cdot \vec{r}_n}= \sum_{n} f_n \cdot e^{- 2 \pi i (hx_n+ky_n+lz_n)}$ -
 структурная амплитуда (раздел ~\ref{sec:structure_factor}),
 коэффициент $h$ в $F_h$ - означает конкретные значения индексов {hkl}; $V$ - объем элементарной ячейки кристалла.

\newpage
\begin{center}
\section{ }%Волновое уравнение
\label{sec:wave_equation}
\end{center}


  воспользоваться операторным тождеством
 \begin{equation}
   rot \quad rot \vec{E} = grad \quad div \vec{E} - \Laplace \vec{E}
  \end{equation}

\newpage
  \begin{center}
  \section{ }%функция кристалла
  \label{sec:sample_functions}
  \end{center}
{\scriptsize
\begin{lstlisting}[language=Python]

#-----------Монохроматор-----------
# статичный элемент
def monohromator(teta, itta, X0, Xh, tetaprmtr_deg, fi):
    tetaprmtr = math.radians(tetaprmtr_deg)
    gamma_0 = math.sin(math.radians(fi) + tetaprmtr)
    gamma_h = math.sin(math.radians(fi) - tetaprmtr)
    b = gamma_0/abs(gamma_h)  # коэффициент ассиметрии
    #брэговского отражения
    C = 1
    monohrom = teta-(itta-1)*math.tan(tetaprmtr)
    # угловая отстройка падающего излучения от угла Брегга
    alfa = -4*math.sin(tetaprmtr) * \
        (math.sin(tetaprmtr+monohrom)-math.sin(tetaprmtr))
    prover = (1/4/gamma_0)* \
        (X0*(1-b)-b*alfa+cmath.sqrt(((X0*(1+b)+b*alfa) * \
        (X0*(1+b)+b*alfa))-4*b*(C*C) * \
        ((Xh.real)*(Xh.real)-(Xh.imag)*(Xh.imag)-2j*Xh.real*Xh.imag)))

    if prover.imag < float(0):
        eps = (1/4/gamma_0)* \
            (X0*(1-b)-b*alfa-cmath.sqrt(((X0*(1+b)+b*alfa) * \
            (X0*(1+b)+b*alfa))-4*b*(C*C) * \
            ((Xh.real)*(Xh.real)-(Xh.imag)*(Xh.imag)-2j*Xh.real*Xh.imag)))
    else:
        eps = prover

    R = (2*eps*gamma_0-X0)/Xh/C
    return (abs(gamma_h)/gamma_0)*abs(R)*abs(R)

#-----------Образец-----------
# подвижный элемент
def sample(dTeta, teta, itta, X0, Xh, tetaprmtr_deg, fi):
    tetaprmtr = math.radians(tetaprmtr_deg)
    gamma_0 = math.sin(math.radians(fi) + tetaprmtr)
    gamma_h = math.sin(math.radians(fi) - tetaprmtr)
    # коэффициент ассиметрии брэговского отражения    # Ignore
    # SpaceConsistencyBear
    b = gamma_0/abs(gamma_h)
    C = 1
    sample = dTeta+teta-(itta-1)*math.tan(tetaprmtr)
    # угловая отстройка падающего излучения от угла Брегга
    alfa = -4*math.sin(tetaprmtr) * \
        (math.sin(tetaprmtr+sample)-math.sin(tetaprmtr))

    prover = (1/4/gamma_0)* \
        (X0*(1-b)-b*alfa+cmath.sqrt(((X0*(1+b)+b*alfa) * \
        (X0*(1+b)+b*alfa))-4*b*(C*C) * \
        ((Xh.real)*(Xh.real)-(Xh.imag)*(Xh.imag)-2j*Xh.real*Xh.imag)))

    if prover.imag < float(0):
        eps = (1/4/gamma_0)* \
            (X0*(1-b)-b*alfa-cmath.sqrt(((X0*(1+b)+b*alfa) * \
            (X0*(1+b)+b*alfa))-4*b*(C*C) * \
            ((Xh.real)*(Xh.real)-(Xh.imag)*(Xh.imag)-2j*Xh.real*Xh.imag)))
    else:
        eps = prover

    R = (2*eps*gamma_0-X0)/Xh/C

    return (abs(gamma_h)/gamma_0)*abs(R)*abs(R)


\end{lstlisting}
}
